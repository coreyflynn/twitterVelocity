{"version":3,"names":[],"mappings":"","sources":["bundle.js"],"sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n// build an event dispatcher to coordinate the different pieces of the UI\nvar events = require('./events');\nevents.buildDispatcher();\n\n// set up a socket connnection to our twitter stream server\nrequire('./socket');\n\n// build the UI\nrequire('./ui');\n\n},{\"./events\":2,\"./socket\":3,\"./ui\":9}],2:[function(require,module,exports){\n/**\n * build the top level event dispather\n * @return {null}\n */\nfunction buildDispatcher() {\n  window.dispatcher = _.clone(Backbone.Events);\n}\n\nmodule.exports = {\n  buildDispatcher: buildDispatcher\n}\n\n},{}],3:[function(require,module,exports){\nvar previousTweetCount,\n    maxVelocity = 0,\n    maxAcceleration = 0,\n    currentTweetCount = 0,\n    paused = false;\n\nif(io !== undefined) {\n  socket = io.connect('http://localhost:3000');\n\n  // This listens on the \"twitter-steam\" channel and data is\n  // received everytime a new tweet is receieved.\n  socket.on('twitter-stream', function (data) {\n\n  });\n\n  // Listens for a success response from the server to\n  // say the connection was successful.\n  socket.on(\"connected\", function(r) {\n    console.log('connected to tweet server');\n  });\n\n  socket.on('tweet', function(tweet){\n    if (!paused) {\n      dispatcher.trigger('newTweet', tweet);\n      currentTweetCount += 1;\n    }\n  });\n\n  // update our tweet counts and dispatch an update every second\n  setInterval(function(){\n    if (!paused){\n      var velocity = currentTweetCount,\n          acceleration = currentTweetCount - previousTweetCount;\n      maxVelocity = (velocity > maxVelocity) ?\n                              velocity : maxVelocity;\n      maxAcceleration = (acceleration > maxAcceleration) ?\n                              acceleration : maxAcceleration;\n      dispatcher.trigger('countUpdate',{\n        velocity: velocity,\n        acceleration: acceleration,\n        maxVelocity: maxVelocity,\n        maxAcceleration: maxAcceleration\n        });\n\n      previousTweetCount = currentTweetCount;\n      currentTweetCount = 0;\n      velocity = 0;\n    }\n  },1000);\n\n  // reset the max values if we filter\n  dispatcher.on('filter',function(){\n    maxVelocity = 0;\n    maxAcceleration = 0;\n  });\n\n  dispatcher.on('pause/play', function(){\n    if (paused) {\n      paused = false;\n    } else {\n      paused = true;\n    }\n  });\n}\n\n},{}],4:[function(require,module,exports){\n/**\n * attach counters to the DOM\n * @return {null}\n */\nfunction attach() {\n  var velocityCounterModel = new Barista.Models.GenericCountModel();\n  var velocityCounter = new Barista.Views.GenericCountView({\n    el:'#counters',\n    model: velocityCounterModel,\n    span_class: 'col-sm-3 col-xs-6',\n    label: 'Tweet Velocity',\n    png: false\n    });\n\n  var maxVelocityCounterModel = new Barista.Models.GenericCountModel();\n  var maxVelocityCounter = new Barista.Views.GenericCountView({\n    el:'#counters',\n    model: maxVelocityCounterModel,\n    span_class: 'col-xs-3 hidden-xs',\n    label: 'Maximum Velocity',\n    png: false\n    });\n\n  var accelerationCounterModel = new Barista.Models.GenericCountModel();\n  var accelerationCounter = new Barista.Views.GenericCountView({\n    el:'#counters',\n    model: accelerationCounterModel,\n    span_class: 'col-sm-3 col-xs-6',\n    label: 'Tweet Acceleration',\n    png: false\n    });\n\n  var maxAccelerationCounterModel = new Barista.Models.GenericCountModel();\n  var maxAccelerationCounter = new Barista.Views.GenericCountView({\n    el:'#counters',\n    model: maxAccelerationCounterModel,\n    span_class: 'col-xs-3 hidden-xs',\n    label: 'Maximum Acceleration',\n    png: false\n    });\n\n  // listen for update events and update the counters when they come in\n  dispatcher.on('countUpdate',function(update){\n    velocityCounter.model.set({'count': update.velocity});\n    accelerationCounter.model.set({'count': update.acceleration});\n    maxVelocityCounter.model.set({'count': update.maxVelocity});\n    maxAccelerationCounter.model.set({'count': update.maxAcceleration});\n  });\n\n  // reset the max counters if we filter\n  dispatcher.on('filter',function(){\n    maxVelocityCounterModel.set({'count': 0});\n    maxAccelerationCounterModel.set({'count': 0});\n  });\n}\n\nmodule.exports = {\n  attach: attach\n}\n\n},{}],5:[function(require,module,exports){\n/**\n * attach pause/play logic to the pause element in the DOM\n * @return {null}\n */\nfunction attach() {\n  $('#pause').click(function(){\n    dispatcher.trigger('pause/play');\n\n    // if we are paused, transition to play and vice verse\n    if ($('.pause-1').length){\n      $('.pause-1').removeClass('pause-1').addClass('play-1');\n      $('.pause-2').removeClass('pause-2').addClass('play-2');\n      $('.pause-3').removeClass('pause-3').addClass('play-3');\n    } else {\n      $('.play-1').removeClass('play-1').addClass('pause-1');\n      $('.play-2').removeClass('play-2').addClass('pause-2');\n      $('.play-3').removeClass('play-3').addClass('pause-3');\n    }\n  });\n}\n\nmodule.exports = {\n  attach: attach\n}\n\n},{}],6:[function(require,module,exports){\nfunction attach() {\n  // set up a scatter plot model\n  scatterModel = new Barista.Models.ScatterPlotModel({\n    title: 'Tweet velocity over time',\n    x_axis_title: 'seconds',\n    y_axis_title: 'velocity'\n  });\n\n  // set up the scatter plot view\n  scatter = new Barista.Views.ScatterPlotView({\n    el: $(\"#scatter\"),\n    model: scatterModel,\n\t\tspan_class: \"col-xs-12\",\n    plot_height: 250,\n    png: false\n  });\n\n\n  // listen for update events and update the plot when they come in\n  var updateCount = 0;\n  dispatcher.on('countUpdate',function(update){\n    updateCount += 1;\n    // update the data\n    newXData = scatter.model.get('x_data');\n    newXData.push(updateCount);\n    newYData = scatter.model.get('y_data');\n    newYData.push(update.velocity);\n\n    // if the data is holding more than three minutes of tweets, start rolling\n    // the time window\n    if (newXData.length >= 180) {\n      newXData.shift();\n      newYData.shift();\n    }\n\n    // update the scatter model\n    scatter.model.set({\n      x_data: newXData,\n      y_data: newYData\n    });\n    scatter.update();\n  });\n\n  // reset the data in the plot if we filter\n  dispatcher.on('filter',function(){\n    scatter.model.set({\n      x_data: [],\n      y_data: []\n    });\n\n    updateCount = 0;\n  });\n}\n\n\nmodule.exports = {\n  attach: attach\n}\n\n},{}],7:[function(require,module,exports){\n/**\n * attach a search handler to input at the top of the app\n * @return {null}\n */\nfunction attach() {\n  $(\"#search\").bind('input propertychange change', _.throttle(change_callback,250));\n}\n\n/**\n * updates the current filter used on the twitter stream. The new filter is\n * passed over our socket to update the stream coming from the server\n * @return {null}\n */\nfunction change_callback() {\n  var val  = $(\"#search\").val();\n  socket.emit('filter',val);\n  dispatcher.trigger('filter',val);\n}\n\nmodule.exports = {\n  attach: attach\n}\n\n},{}],8:[function(require,module,exports){\n/**\n * attach a new tableCloth table to the DOM\n * @return {null}\n */\nfunction attach() {\n  // instantiate a tableCloth table\n  var targetHeight = $(window).height() - $('#tweetTable').offset().top - 50;\n  var tc = new tableCloth('tweetTable',{height: targetHeight});\n\n\n  // add a custom click handler to the basicCell prototype\n  basicCell = tc.cellFactory.basicCell;\n  basicCell.prototype.click = function() {\n    window.location.href = 'https://twitter.com/statuses/' +\n                              this.options.tweet.id_str;\n  }\n\n  // put new cells in that table as tweets come in\n  dispatcher.on('newTweet',function(tweet){\n    tc.cellManager.addCellAtIndex(\n      new tc.cellFactory.basicCell({\n        label: tweet.text,\n        tweet: tweet\n      }),0);\n  });\n\n  // clear tweets if we filter\n  dispatcher.on('filter',function(){\n    tc.cellManager.cells = [];\n    tc.cellManager.renderCells();\n  });\n}\n\nmodule.exports = {\n  attach: attach\n}\n\n},{}],9:[function(require,module,exports){\nvar counters = require('./components/counters');\nvar tweetTable = require('./components/tweetTable');\nvar search = require('./components/search');\nvar scatter = require('./components/scatter');\nvar pause = require('./components/pause');\n\ncounters.attach();\nsearch.attach();\nscatter.attach();\ntweetTable.attach();\npause.attach();\n\n},{\"./components/counters\":4,\"./components/pause\":5,\"./components/scatter\":6,\"./components/search\":7,\"./components/tweetTable\":8}]},{},[1]);\n"],"file":"bundle.js","sourceRoot":"/source/"}